import sqlite3
from scriptingFunctions import funcs

class generalDbFunctions:

    def createUsersTable():
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor() #Cursor tells database what to do

        #Creates user table with fields username and password
        cur.execute("""CREATE TABLE users (
            
            username text,
            password text
        )
        """)
        #Commit changes the DB
        con.commit()
        #Close connection to DB
        cur.close()


    def createFoldersTable():
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor() #Cursor tells database what to do
        #Create Folder table with fields folderName and folderOwner
        cur.execute("""CREATE TABLE folders (
            
            folderName text,
            folderOwner text,
            folderID integer,
            FOREIGN KEY(folderOwner) REFERENCES users(username)
        )
            
        """)
        #Commit changes the DB
        con.commit()
        #Close connection to DB
        cur.close()


    #Create Articles Table    
    def createArticlesTable():
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor() #Cursor tells database what to do

        cur.execute("""CREATE TABLE articles(
            articleID integer,
            articleTitle text,
            articleKeyWords text,
            articleNotes text,
            articleSummary text,
            articleFolderIn int,
            FOREIGN KEY(articleFolderIn) REFERENCES folders(folderID)
        )
        """)

        #Commit changes the DB
        con.commit()
        #Close connection to DB
        cur.close()


    def refreshTables():
        #Drops, recreates and outputs tables
        """
        DO NOT USE UNLESS NECESSARY
        """
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor() #Cursor tells database what to do

        cur.execute("DROP TABLE users")
        cur.execute("DROP TABLE folders")
        cur.execute("DROP TABLE articles")
        generalDbFunctions.createArticlesTable()
        generalDbFunctions.createFoldersTable()
        generalDbFunctions.createUsersTable()
        generalDbFunctions.returnContentsofTable("users")
        generalDbFunctions.returnContentsofTable("folders")
        generalDbFunctions.returnContentsofTable("articles")    

        #Commit changes the DB
        con.commit()
        #Close connection to DB
        cur.close()

    def returnContentsofTable(table):
        #Returns the contents of the table
        #This will allow me to test each table, one universal function rather than
        #a function for each table -> less written code therefore easier to read

        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor() #Cursor tells database what to do

        cur.execute("SELECT * FROM {}".format(table))
        print(cur.fetchall())

        #Commit changes the DB
        con.commit()
        #Close connection to DB
        cur.close()
    
    def tupToString(tup):
        #Convert a tuple to a string so program can understand data retrieved from database
        
        returnedString = "".join([x[0] for x in tup])
        
        return returnedString
    
    
    def tupToStringSingle(tup,n):
        #Returns the nth element of a tuple
        valueAtn = tup[n]  
        print(valueAtn)
        returnedString = "".join([x[n] for x in valueAtn])
        print(returnedString)    
    
        
        
class usersTableFunctions:
            
    def usernameAvailable(Username):
        #Check if the username already exists, keeps usernames unique
        #Return any records in the user table with that username
        #If length not equal to zero then username taken return false
    
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor() #Cursor tells database what to do

        lengthCheck = usersTableFunctions.returnUsername(Username)

        #Commit changes the DB
        con.commit()
        #Close connection to DB
        cur.close()
        if len(lengthCheck) != 0:
            return False
        elif len(lengthCheck) == 0:
            return True
        
        
    def returnUsername(Username):
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor() #Cursor tells database what to do

        cur.execute("SELECT username FROM users WHERE username = '{}'".format(Username))
        uname = cur.fetchall()
        
        username = generalDbFunctions.tupToString(uname)
        
        #Commit changes the DB
        con.commit()
        #Close connection to DB
        cur.close()

        return username
    
       
    def returnPassword(username):
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor() #Cursor tells database what to do

        cur.execute("SELECT password FROM users WHERE username='{}'".format(username))
        pword = cur.fetchall()
        pword = generalDbFunctions.tupToString(pword)

        #Commit changes the DB
        con.commit()
        #Close connection to DB
        cur.close()
        return pword
    
    def createUser(username, password):
        #username and password will be added into the database
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor() #Cursor tells database what to do

        cur.execute("INSERT INTO users VALUES (?,?)",(username, password))
        #Commit changes the DB
        con.commit()
        #Close connection to DB
        cur.close()

"""
generalDbFunctions.refreshTables()       
usersTableFunctions.createUser("test","passwordlol")
generalDbFunctions.returnContentsofTable("users")
"""

class foldersTableFunctions:
    def folderNameAvailable(folderName, username):
        if len(folderName) > 0:#Return false if user has not entered a folder name
            
        

            #Check if the folder name has already been taken, user cannot have more than one folder with the same name
            con = sqlite3.connect('users.db') #Establishes connection to the Database
            cur = con.cursor()
            #Query database to return any folder names with that name and owner
            cur.execute("SELECT folderName FROM folders WHERE folderOwner='{}' AND folderName ='{}'".format(username, folderName))
            returnedFolders = cur.fetchall()

            con.commit()
            con.close()
            returnedFolders = generalDbFunctions.tupToString(returnedFolders)#Convert returned data into string which can then be compared
            print(returnedFolders)
            if len(returnedFolders) > 0:#If the user already has a folder of that name, a value will be returned therefore length will be larger than zero
                return False#Return false if user already has folder of that name
            else: 
                return True
        else:
            return False#Return true if available

    def returnFolders(username):
        #Returns all of a user's folders'
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor()
        
        cur.execute("SELECT folderName FROM folders WHERE folderOwner='{}'".format(username))#Retrieves all folder names from username, store as returnedFolders
        returnedFolders = cur.fetchall()

        con.commit()
        con.close()
        return returnedFolders#Return all of the folder names

    def returnFolderID(folderName, folderOwner):
        #Returns the folder ID of a folder
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor()
        
        #Return the ID of the folder and store in returnedID
        returnedID = cur.execute("SELECT folderID FROM folders WHERE folderName='{}' AND folderOwner='{}'".format(folderName, folderOwner))
        returnedID = cur.fetchall()
        
        con.commit()
        con.close()
        #If a value is returned, convert the retrieved value to a string
        if len(returnedID) > 0:
            #Converts retrieved value into a string
            returnedID = returnedID[0]
            returnedID = returnedID[0]
            return returnedID
        

    def folderIDAvailable(newID):
        #Check folderID is available, if folderID already in db, returns False
        # If not found in db return True 
        #Ensures folderID is always primary key
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor()

        cur.execute("SELECT folderID FROM folders WHERE folderID='{}'".format(newID))#Queries database for folderID, stores in variable retrievedID
        retrievedID = cur.fetchall()

        con.commit()#Commits query to db
        con.close()#Closes connection to database
        if len(retrievedID) > 0:
            retrievedID = retrievedID[0]
            retrievedID = retrievedID[0]
        else:
            return True
        
        #If the retrievedID is equal to the newID, ID already exists, return False, else ID is available return True

        if retrievedID == newID:
            return False
        else:
            return True
        

    def createFolder(folderName,folderOwner):
        #Creates a new folder
        if usersTableFunctions.usernameAvailable(folderOwner) == False:
            folderID = funcs.createPk()#Reuses general function to create a primary key for the folder
            if foldersTableFunctions.folderNameAvailable(folderName,folderOwner) == True:#The folder name is then checked to make sure it is unique for that user
                if foldersTableFunctions.folderIDAvailable(folderID) == True:#The primary key is checked to make sure it is unique
                    #If both are unique, the folder is created
                    con = sqlite3.connect('users.db') #Establishes connection to the Database
                    cur = con.cursor() #Cursor tells database what to do
                    
                    cur.execute("INSERT INTO folders VALUES (?,?,?)",(folderName,folderOwner,folderID))#Inserts all folder attributes into database to create folder

                    #Commit changes the DB
                    con.commit()
                    #Close connection to DB
                    cur.close()
           


class articlesTableFunctions:

    def articleTitleAvailable(folderID,articleTitle):
        
        #Check to see if the article title already exists within the folder
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor() #Cursor tells database what to do

        #Queries database for any article Titles in the folder that already exist and stores in variable returnedTitle
        cur.execute("SELECT articleTitle FROM articles WHERE articleFolderIn='{}' AND articleTitle='{}'".format(folderID, articleTitle))
        returnedTitle = cur.fetchall()

        con.commit()#Commit changes to database
        cur.close()#Close database


        returnedTitle = generalDbFunctions.tupToString(returnedTitle)#Convert any returned values to string so they can be compared 
        if returnedTitle == articleTitle:#If title returned from database same as title passed as parameter then article title already exists, return False
            return False
        else:#Else title doesn't exist, return True
            return True

    def returnArticleTitles(folderID):
        #Return all article titles that belong to a folder
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor() #Cursor tells database what to do

        cur.execute("SELECT articleTitle FROM articles WHERE articleFolderIn='{}'".format(folderID))#Return all article titles in folder
        returnedArticles = cur.fetchall()#Store article titles in variable returnedArticles
        #Commit changes to the DB
        con.commit()
        #Close connection to DB
        cur.close()
        return returnedArticles #return all articles

    
    def articleIDAvailable(articleID):
        #Checks if an article ID is available
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor()
        #Return all articleIDs that have the articleID we are checking
        cur.execute("SELECT articleID FROM articles WHERE articleID ='{}'".format(articleID))
        returnedID = cur.fetchall()

        con.commit()
        cur.close()
        
        #returnedID will be in a tuple, this needs to be converted into an integer, this only needs to be done if an ID has been found in the database
        if len(returnedID) > 0:

            returnedID = returnedID[0]

            returnedID = returnedID[0]
            
        #If returnedID is equal to articleID, articleID already in use, return False. Else, articleID available, return True.
        if returnedID == articleID:
            return False
        else:
            return True


    def createArticle(articleTitle, articleFolderIn):
        
        articleID = funcs.createPk()
        articleKeywords = ""
        articleKeyWords = articleKeywords
        articleNotes = ""
        articleSummary = ""
        if articlesTableFunctions.articleTitleAvailable(articleFolderIn,articleTitle) == True:#Make sure the article title is not already in the folder
            #Make sure primary key doesn't already exist
            if articlesTableFunctions.articleIDAvailable(articleID) == True:
                
                con = sqlite3.connect('users.db') #Establishes connection to the Database
                cur = con.cursor()#Cursor tells database what to do
                #Create an article with the article title entered by user and blank fields that can be edited by the user
                cur.execute('INSERT INTO articles VALUES (?,?,?,?,?,?)',(articleID,articleTitle,articleKeyWords,articleNotes,articleSummary,articleFolderIn))
                #Commit changes the DB
                con.commit()
                #Close connection to DB
                cur.close()
    """
    STAGE 3
    """
    def returnArticleID(articleName,articleFolderIn):
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor()
        cur.execute("SELECT articleID FROM articles WHERE articleTitle='{}' AND articleFolderIn='{}'".format(articleName,articleFolderIn))
        returnedID = cur.fetchall()

        con.commit()
        cur.close()
        if len(returnedID) > 0:
            returnedID = returnedID[0]
            returnedID = returnedID[0]
            return returnedID
    """
    articleID integer,
                articleTitle text,
                articleKeyWords text,
                articleNotes text,
                articleSummary text,
                articleFolderIn int,
    """
    def editArticle(articleID,articleTitle,articleKeyWords,articleNotes,articleSummary):
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor()
        #Edit the article Title
        cur.execute("UPDATE articles SET articleTitle='{}'WHERE articleID='{}'".format(articleTitle,articleID))
        #Edit the keywords in the article 
        cur.execute("UPDATE articles SET articleKeyWords='{}'WHERE articleID='{}'".format(articleKeyWords,articleID))
        #Edit the Notes in the article
        cur.execute("UPDATE articles SET articleNotes='{}'WHERE articleID='{}'".format(articleNotes,articleID))
        #Edit the summary in the article
        cur.execute("UPDATE articles SET articleSummary='{}'WHERE articleID='{}'".format(articleSummary,articleID))

        con.commit()
        cur.close()

    def returnArticleKeyWords(articleID):
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor()

        cur.execute("SELECT articleKeyWords FROM articles WHERE articleID='{}'".format(articleID))
        returnedKeyWords = cur.fetchall()

        con.commit()
        cur.close()
        
        returnedKeyWords = generalDbFunctions.tupToString(returnedKeyWords)
        return returnedKeyWords

    def returnArticleNotes(articleID):
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor()

        cur.execute("SELECT articleNotes FROM articles WHERE articleID='{}'".format(articleID))
        returnedNotes = cur.fetchall()

        con.commit()
        cur.close()
        
        returnedNotes = generalDbFunctions.tupToString(returnedNotes)
        return returnedNotes

    def returnArticleSummary(articleID):
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor()

        cur.execute("SELECT articleSummary FROM articles WHERE articleID='{}'".format(articleID))
        returnedSummary = cur.fetchall()

        con.commit()
        cur.close()
        
        returnedSummary = generalDbFunctions.tupToString(returnedSummary)
        return returnedSummary
"""
folderID= foldersTableFunctions.returnFolderID("Personal","newUsername")
articleID = articlesTableFunctions.returnArticleID("Quantum",folderID)
articlesTableFunctions.editArticle(articleID,"Quantum","Planck Constant","E=hf and all that","siiim")
generalDbFunctions.returnContentsofTable("articles")
"""
