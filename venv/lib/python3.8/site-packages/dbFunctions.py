import sqlite3

con = sqlite3.connect('users.db') #Establishes connection to the Database

cur = con.cursor() #Cursor tells database what to do


#"rowid acts as primary key for all rows"
class generalDbFunctions:
    #Create User Table
    def createUsersTable():
        cur.execute("""CREATE TABLE users (
            
            username text,
            password text
        )
        """)
    #Create Folder Table
    def createFoldersTable():
        cur.execute("""CREATE TABLE folders (
            
            folderName text,
            folderOwner text,
            FOREIGN KEY(folderOwner) REFERENCES users(username)
        )
            
        """)
    #Create Articles Table    
    def createArticlesTable():
        cur.execute("""CREATE TABLE articles(
            
            articleTitle text,
            articleKeyWords text,
            articleNotes text,
            articleSummary text,
            articleFolderIn int,
            FOREIGN KEY(articleFolderIn) REFERENCES folders(folderName)
        )
        """) 
    def refreshTables():
        #Drops, creates and outputs tables
        """
        DO NOT USE UNLESS NECESSARY
        """
        cur.execute("DROP TABLE users")
        cur.execute("DROP TABLE folders")
        cur.execute("DROP TABLE articles")
        generalDbFunctions.createArticlesTable()
        generalDbFunctions.createFoldersTable()
        generalDbFunctions.createUsersTable()
        generalDbFunctions.returnContentsofTable("users")
        generalDbFunctions.returnContentsofTable("folders")
        generalDbFunctions.returnContentsofTable("articles")    

    def returnContentsofTable(table):
        #Returns the contents of the table
        #This will allow me to test each table, one universal function rather than
        #a function for each table -> less written code therefore easier to read
        cur.execute("SELECT * FROM {}".format(table))
        print(cur.fetchall())
    
    def tupToString(tup):
        #Convert a tuple to a string
        returnedString = "".join([x[0] for x in tup])
        return returnedString

class usersTableFunctions:
            
    def usernameAvailable(Username):
        #Check if the username already exists, keeps usernames unique
        #Return any records in the user table with that username
        #If length not equal to zero then username taken return false
        #If counter equals zero, username available, return true

        #Database connection always opened and closed within function so that database
        #isn't constantly open -> makes database less vulnerable
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor() #Cursor tells database what to do

        lengthCheck = usersTableFunctions.returnUsername(Username)

        #Commit changes the DB
        con.commit()
        #Close connection to DB
        cur.close()
        if len(lengthCheck) != 0:
            return False
        elif len(lengthCheck) == 0:
            return True
        
        
    def returnUsername(Username):
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor() #Cursor tells database what to do

        cur.execute("SELECT username FROM users WHERE username = '{}'".format(Username))
        uname = cur.fetchall()
        
        username = generalDbFunctions.tupToString(uname)
        
        #Commit changes the DB
        con.commit()
        #Close connection to DB
        cur.close()

        return username
    
       
    def returnPassword(username):
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor() #Cursor tells database what to do

        cur.execute("SELECT password FROM users WHERE username='{}'".format(username))
        pword = cur.fetchall()
        pword = generalDbFunctions.tupToString(pword)

        #Commit changes the DB
        con.commit()
        #Close connection to DB
        cur.close()
        return pword
    
    def createUser(username, password):
        #username and password will be added into the database
        con = sqlite3.connect('users.db') #Establishes connection to the Database
        cur = con.cursor() #Cursor tells database what to do

        usernameUnique = usersTableFunctions.usernameAvailable(username)

        cur.execute("INSERT INTO users VALUES (?,?)",(username, password))
        #Commit changes the DB
        con.commit()
        #Close connection to DB
        cur.close()

"""
generalDbFunctions.refreshTables()       
usersTableFunctions.createUser("test","passwordlol")
generalDbFunctions.returnContentsofTable("users")
"""
generalDbFunctions.returnContentsofTable("users")

#print(usersTableFunctions.returnUsername("test"))



class foldersTableFunctions:
    pass
class articlesTableFunctions:
    pass


#Commit changes the DB
con.commit()
#Close connection to DB
cur.close()